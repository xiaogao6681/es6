<script>
"use strict";
//let命令，所声明的变量，只在let命令所在的代码块内有效。
/*{
	let a = 10;
	var b = 1;
}
console.log(b);
console.log(a);*/


/*---------------let块级作用域--------------------------*/
/*var a = [];
for(let i = 0;i<10;i++){//let声明的变量只在块级作用域内有效，最后输出的是6.
	a[i]=function(){
		console.log(i);
	}
};
a[6]()*/

/*-----------------不存在变量提升------------------------*/
/*console.log(foo);
var foo = 2; //此时输出是undefined

console.log(bar); //此时报错是reference：bar is not defined
let bar =2;*/


/*---------------暂时性死区--------------------------*/
//只要块级作用域内存在let命令，它所声明的变量就binding在这个区域，不受外部的影响。
/*var tmp = 123;
if(true){
	tmp = 'abc';
	let tmp;//在let声明变量前，对tmp赋值就会报错。
}*/

/*---------------块级作用域--------------------------*/
//块级作用域的出现，实际上使得获得广泛应用的立即执行表达式不再是必要的了。
/*var tmp = new Date();
function f(){
	console.log(tmp);
	if(false){
		var tmp = 'hello world';
	}
}
f();  //undefined  由于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。

function f1(){
	let n = 5;
	if(true){
		let n = 10;
	}
	console.log(n);
}
f1();*/ //5 表示外层代码块不受内层代码块的影响。

/*---------------do表达式--------------------------*/
/*let x = do {
	let t = f();
	t*t + 1;
};*/


/*---------------const--------------------------*/
//const:声明一个只读的常量。一旦声明，常量的值就不能改变。这也就意味着const一旦声明变量，就必须
//立即初始化，不能留到以后赋值。const的作用域和let命令相同：只在声明所在的块级作用域内有效。
</script>
