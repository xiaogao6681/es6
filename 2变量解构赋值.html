<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>es6</title>
</head>
<body>
	<p>切记在火狐浏览器下面使用</p>
</body>
</html>
<script>
	"use strict";
	/*-----------解构数值-------------*/
	/*let [a,b,c]=[1,2,3];//该种写法属于模式匹配，从数组和对象中提取值，对变量进行赋值，这被称为解构
	console.log(a,b,c);
	let [foo, [[baz], bar]] = [1, [[2], 3]];
	console.log(foo,baz,bar);
	let [head,...tail]=[1,2,3,4];
	console.log(tail);
	let [foo1]=1;
	console.log(foo1);//若等号的右边不是数组（严格地说，是不可遍历的结构，将会报错）*/



	/*--------只要某种数据解构具有Iterator(迭代)接口，都可以采用数组形式的解构----------*/
	/*let [x,y,z]=new Set(['a','b','c']);
	console.log(x);
	function* fibs() {//首先构造一个生成器函数
	  let a = 0;
	  let b = 1;
	  while (true) {
	    yield a; //yield关键字的返回值
	    [a, b] = [b, a + b];
	  }
	}

	let [first, second, third, fourth, fifth, sixth] = fibs();
	console.log(fourth);*/

	/*-----------对象的解构赋值-------------*/
	//对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值是由它的位置决定；而对象的属性没有次序，
	//变量必须与属性同名，才能取到正确的值。
	/*let {foo,bar} = {foo:'aaa',bar:'bbb'};
	console.log(foo,bar);

	let {baz}={foo:'aaa',bar:'bbb'};
	console.log(baz);*/

	//对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者，而不是前者
	/*let {foo:baz} = {foo:'aaa',bar:"bbb"}; //foo是匹配模式，baz才是变量。
	console.log(baz)*/

	/*let obj = {
	  p: [
	    'Hello',
	    { y: 'World' }
	  ]
	};

	//let {p: [x, { y }] } = obj;
	let {p,p:[x,{y}]} = obj;
	console.log(p,x,y);
*/

	/*--------------字符串的解构赋值----------------*/
	const [a,b,c,d,e] = 'hello';
	console.log(a,b,c,d,e);
	//类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值
	let {length:len} = 'hello';
	console.log(len);


	/*函数参数的解构赋值*/

	function add([x,y]){//在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，能感受到的参数就是x和y。
		return x + y;
	}
	var s = add([1,2]);
	console.log(s);

	/*-------用途----------*/
	//交换变量的值
	/*let [x,y]=[1,2];
	[x,y] = [y,x];
	console.log(x,y);

	//从函数返回多个值
	function exam(){
		return [1,2,3];
	}
	let [a,b,c] = exam();
*/
	//提取json数据
	let jsonData = {
		id:42,
		status:'ok',
		data:[867,5309]
	};

	let {id,status,data:number} = jsonData;
	console.log(id,status,number); //此时的number是一个数组对象

	//遍历map结构，任何部署了Iterator接口的对象，都可以有for...of循环遍历。

	var map= new Map();
	map.set('first','hello');
	map.set('second','world'); //此时的map是一个obj

	for(let [key,value] of map){
		console.log(key+" is " + value);
	}
	console.info(typeof map);
</script>